name: Fetch Watching Data

on:
  schedule:
    - cron: '0 0 * * *'  # Daily at midnight UTC
  workflow_dispatch:

permissions:
  contents: write

jobs:
  fetch:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Fetch Trakt data
        id: fetch
        env:
          TRAKT_CLIENT_ID: ${{ secrets.TRAKT_CLIENT_ID }}
          TMDB_API_KEY: ${{ secrets.TMDB_API_KEY }}
        run: |
          set -euo pipefail

          if [ -z "${TRAKT_CLIENT_ID:-}" ]; then
            echo "::warning::TRAKT_CLIENT_ID not configured, skipping"
            exit 0
          fi
          if [ -z "${TMDB_API_KEY:-}" ]; then
            echo "::warning::TMDB_API_KEY not configured, posters will be unavailable"
          fi

          TRAKT_USER="gvns"
          TRAKT_API="https://api.trakt.tv"

          # --- 1. Fetch recent watch history (last 30 items) ---
          HTTP_CODE=$(curl -s -o /tmp/trakt_history.json -w "%{http_code}" \
            -H "Content-Type: application/json" \
            -H "trakt-api-version: 2" \
            -H "trakt-api-key: ${TRAKT_CLIENT_ID}" \
            "${TRAKT_API}/users/${TRAKT_USER}/history?limit=30")

          if [ "$HTTP_CODE" -ne 200 ]; then
            echo "Error: Trakt history API returned HTTP $HTTP_CODE"
            cat /tmp/trakt_history.json 2>/dev/null || true
            rm -f /tmp/trakt_history.json
            exit 1
          fi

          # Validate JSON array
          if ! jq -e 'type == "array"' /tmp/trakt_history.json > /dev/null 2>&1; then
            echo "Error: Trakt history response is not a JSON array"
            rm -f /tmp/trakt_history.json
            exit 1
          fi

          # --- 2. Extract unique TMDB IDs for poster lookup ---
          # Movies: .movie.ids.tmdb, Shows: .show.ids.tmdb
          jq -r '[
            .[] |
            if .type == "movie" then
              { tmdb_id: (.movie.ids.tmdb // empty), media_type: "movie" }
            elif .type == "episode" then
              { tmdb_id: (.show.ids.tmdb // empty), media_type: "tv" }
            else empty end
          ] | unique_by(.tmdb_id) | .[] | "\(.tmdb_id) \(.media_type)"' \
            /tmp/trakt_history.json > /tmp/tmdb_ids.txt 2>/dev/null || true

          # --- 3. Resolve TMDB poster URLs ---
          echo '{}' > /tmp/tmdb_posters.json

          if [ -n "${TMDB_API_KEY:-}" ] && [ -s /tmp/tmdb_ids.txt ]; then
            while IFS=' ' read -r tmdb_id media_type; do
              [ -z "$tmdb_id" ] && continue

              TMDB_HTTP=$(curl -s --max-time 5 -o /tmp/tmdb_item.json -w "%{http_code}" \
                "https://api.themoviedb.org/3/${media_type}/${tmdb_id}?api_key=${TMDB_API_KEY}" || echo "000")

              if [ "$TMDB_HTTP" = "200" ]; then
                POSTER_PATH=$(jq -r '.poster_path // empty' /tmp/tmdb_item.json 2>/dev/null || true)
              else
                echo "::debug::TMDB lookup failed for ${media_type}/${tmdb_id}: HTTP $TMDB_HTTP"
                POSTER_PATH=""
              fi
              rm -f /tmp/tmdb_item.json

              if [ -n "$POSTER_PATH" ]; then
                # Store as: { "movie_12345": "https://image.tmdb.org/t/p/w342/path.jpg" }
                jq --arg key "${media_type}_${tmdb_id}" \
                   --arg url "https://image.tmdb.org/t/p/w342${POSTER_PATH}" \
                   '. + { ($key): $url }' /tmp/tmdb_posters.json > /tmp/tmdb_posters_tmp.json
                mv /tmp/tmdb_posters_tmp.json /tmp/tmdb_posters.json
              fi

              # Be kind to TMDB rate limits
              sleep 0.25
            done < /tmp/tmdb_ids.txt
          fi

          # --- 4. Build watching.json ---
          mkdir -p src/data

          # Compute this-month stats from history
          CURRENT_MONTH=$(date -u +%Y-%m)

          jq --slurpfile posters /tmp/tmdb_posters.json \
             --arg month "$CURRENT_MONTH" '
            # Build poster lookup from first element of slurpfile array
            ($posters[0] // {}) as $poster_map |

            # Deduplicate: sort by grouping key first for deterministic group_by,
            # then group and pick the most recent per title
            sort_by(
              if .type == "movie" then "movie_" + (.movie.ids.trakt | tostring)
              elif .type == "episode" then "show_" + (.show.ids.trakt | tostring)
              else "unknown" end
            ) |
            group_by(
              if .type == "movie" then "movie_" + (.movie.ids.trakt | tostring)
              elif .type == "episode" then "show_" + (.show.ids.trakt | tostring)
              else "unknown" end
            ) | map(sort_by(.watched_at) | reverse | first) |

            # Sort deduplicated results by watched_at descending
            sort_by(.watched_at) | reverse |

            # Count this-month items
            ([ .[] | select(.watched_at | startswith($month)) ] |
              { movies: [ .[] | select(.type == "movie") ] | length,
                shows: [ .[] | select(.type == "episode") ] | length }) as $month_stats |

            # Build output
            {
              lastUpdated: (now | todate),
              recentlyWatched: [
                .[] |
                if .type == "movie" then
                  {
                    title: .movie.title,
                    type: "movie",
                    posterUrl: ($poster_map["movie_" + (.movie.ids.tmdb | tostring)] // null),
                    url: ("https://trakt.tv/movies/" + .movie.ids.slug),
                    watchedDate: .watched_at
                  }
                elif .type == "episode" then
                  {
                    title: (.show.title + " \u2014 S" + (
                      if .episode.season < 10 then "0" else "" end
                    ) + (.episode.season | tostring) + "E" + (
                      if .episode.number < 10 then "0" else "" end
                    ) + (.episode.number | tostring)),
                    type: "show",
                    posterUrl: ($poster_map["tv_" + (.show.ids.tmdb | tostring)] // null),
                    url: ("https://trakt.tv/shows/" + .show.ids.slug),
                    watchedDate: .watched_at
                  }
                else empty end
              ],
              stats: {
                moviesThisMonth: $month_stats.movies,
                showsThisMonth: $month_stats.shows
              }
            }
          ' /tmp/trakt_history.json > src/data/watching.json

          # --- 5. Summary ---
          echo "Successfully fetched watching data"
          jq '{
            recently_watched: (.recentlyWatched | length),
            movies_this_month: .stats.moviesThisMonth,
            shows_this_month: .stats.showsThisMonth
          }' src/data/watching.json

          # Cleanup
          rm -f /tmp/trakt_history.json /tmp/tmdb_ids.txt /tmp/tmdb_posters.json

      - name: Commit and push if changed
        if: steps.fetch.outcome == 'success' && hashFiles('src/data/watching.json') != ''
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add src/data/watching.json
          git diff --staged --quiet || git commit -m "chore: update watching data"
          if ! git push 2>&1; then
            echo "::warning::git push failed (branch may be protected). Data committed locally but not pushed."
          fi
